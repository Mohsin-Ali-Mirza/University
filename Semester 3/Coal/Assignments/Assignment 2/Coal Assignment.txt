********************************************************* Q1 ****************************************************************
Include Irvine32.inc

.data
arrA sdword 30,-40,20,65,80,45
j sdword ?
k sdword ?
str1 byte "Enter The Value Of J:",0
str2 byte "Enter The Value Of K:",0



.code 

sumArr PROTO arr:ptr sdword, from:ptr sdword, to:ptr sdword,  n:dword

main PROC

call TakeInput
invoke sumArr, ADDR arrA, j,k, lengthof arrA
call writeint
call crlf
call TakeInput
invoke sumArr, ADDR arrA,j,k,lengthof arrA
call writeint

exit
main ENDP

TakeInput PROC
push edx
push eax
mov edx,offset str1
call writestring
call readdec
mov j,eax

mov edx,offset str2
call writestring
call readdec
mov k,eax
pop eax
pop edx
ret
TakeInput ENDP

sumArr PROC arr:ptr sdword, from:ptr sdword, to:ptr sdword, n:dword
push esi
push ebx
push ecx
mov eax,0
mov ecx,0
mov esi,0
mov esi,arr

jmp condition

do:
add eax,[esi]
add esi,4
inc ecx

condition:
mov ebx, from
cmp [esi],ebx
jge condition2
jmp continue

condition2:
mov ebx,to
cmp [esi],ebx
jle condition3
jmp continue

condition3:
cmp ecx,n
jne do
jmp quit

continue:
add esi,4
inc ecx
jmp condition


quit:
pop ecx
pop ebx
pop esi

ret
sumArr ENDP
end main
********************************************************* Q2 ****************************************************************
Include Irvine32.inc

.data
arr dword 60,4,17,45,7

.code

swap PROC
push [esi]
push [edi]
pop [esi]
pop [edi]
ret
swap ENDp

selectSort PROC, arrOff: ptr dword, len: dword
mov ecx,len
mov esi,arrOff

l1:
	mov eax,0
	mov edx,ecx
	push esi
L2:
	cmp [esi],eax
	jae work
	jmp elsesecond
	work:
	mov eax,[esi]
	mov edi,esi
	elsesecond:
	add esi,4
Loop L2
sub esi,4
call swap
pop esi
mov ecx,edx
Loop l1
ret
selectSort ENDP

main PROC
invoke selectSort, addr arr, lengthof arr
mov ecx, lengthof arr
mov esi, offset arr
l1:
	mov eax,[esi]
	call writedec
	call crlf
	add esi,4
Loop l1

exit
main ENDP

END main
********************************************************* Q3 ****************************************************************
Include Irvine32.inc

.data
arr dword 10 DUp (?)
s1 byte "Enter Value: "
.code

swap PROC
push [esi]
push[edi]
pop[esi]
pop[edi]
ret
swap ENDP

bubble PROC, arrOff:ptr dword
mov ecx, ebx
mov esi, arrOff
dec ecx

l1:
mov eax,ecx
mov edi,esi
add edi,4
l2:
mov edx,[edi]
cmp [esi],edx
ja work
jmp elsesecond
work:
call swap
elsesecond:
add edi,4
loop l2

add esi,4
mov ecx,eax
loop l1
ret
bubble ENDP

main PROC

mov ecx,lengthof arr
mov edx,offset s1
mov esi,0

l3:
call writestring
call readdec
call crlf
mov arr[esi],eax
add esi,4
loop l3


mov ebx,lengthof arr
invoke bubble, addr arr
mov ecx,lengthof arr
mov esi, offset arr
l1:
mov eax, [esi]
call writedec
call crlf
add esi,4
loop l1

exit 
main ENDP
end main

********************************************************* Q4 ****************************************************************
Include Irvine32.inc

.data
str1 byte "Enter N:",0

.code

FACTORIAL PROTO

main PROC
mov edx, offset str1
call writestring
call readdec
mov ecx,eax
invoke FACTORIAL

exit 
main ENDP

FACTORIAL PROC 
mov eax,1

jmp checkCondition

do:
mul ecx
dec ecx

checkCondition:
cmp ecx,0
ja do

call writedec
ret
FACTORIAL ENDP
end main

********************************************************* Q5 **************************************************************************
Include Irvine32.inc

.data
str1 byte "TYPE A CHARACTER:",0
str2 byte "THE ASCII CODE OF '",0
str4 byte "' IN BINARY IS: ",0
str3 byte "THE NUMBER OF 1 BITS IS: ",0
count dword ?


.code
main PROC
mov edx, offset str1
call writestring
call readchar
call crlf
mov edx,offset str2
call writestring
call writechar
mov edx,offset str4
call writestring
call writebin
call crlf

mov ecx,32
l1:
	rol eax,1
	jnc continue
	inc count

	continue:
loop l1

mov eax,count
mov edx,offset str3
call writestring
call writedec

exit
main ENDP
end main

********************************************************* Q6 ****************************************************************
Include Irvine32.inc
.data

arrA sdword -5,-2,3,17
arrB sdword 5,-2,3,-69,420
arrLen dword 2 DUP(?)

.code

CountMatches PROTO arr1:ptr sdword, arr2:ptr sdword, Len:ptr dword

main PROC
mov esi,0
mov arrLen[esi*type arrLen],lengthof arrA
inc esi
mov arrLen[esi*type arrLen],lengthof arrB

invoke CountMatches, ADDR arrA, ADDR arrB, ADDR arrLen



exit
main ENDP

CountMatches PROC arr1:ptr sdword, arr2:ptr sdword, Len:ptr dword 
LOCAL count:dword
mov eax, 0
mov count,0
pushad
mov esi, Len
mov ebx, [esi]
add esi, 4
cmp ebx,[esi]				;Arr1 > Arr2
jg l1

l1:
sub esi,4
mov ecx,[esi]
jmp continue

l2:
mov ecx,[esi]

continue:
l3:
mov esi,arr1
add esi,count
mov ebx,[esi]
mov esi,arr2
add esi,count
cmp ebx,[esi]
jne next
inc eax

next:
add count,4
loop l3

call writedec

popad
ret
CountMatches ENDP
end main


********************************************************* Q7 ****************************************************************
INCLUDE Irvine32.inc


.data
op1 QWORD 0A2B2A40674981234h
op2 QWORD 08010870000234502h
result QWORD 1 DUP(0) ; = 22A21D067474CD32h
msg BYTE "The difference equals ",0
DoubleWords = SIZEOF op1 / TYPE DWORD


.code
main PROC
mov esi, OFFSET op1
mov edi, OFFSET op2
mov ebx, OFFSET result
mov ecx, DoubleWords
call Extended_Sub
mov edx, OFFSET msg
call WriteString
mov esi, OFFSET result
add esi, DoubleWords * 4
mov ecx, DoubleWords
L1: sub esi, TYPE DWORD
mov eax, [esi]
call WriteHex
loop L1
call Crlf
exit
main ENDP

Extended_Sub PROC
pushad
clc
L1: mov eax,[esi]
sbb eax,[edi]
pushfd
mov [ebx],eax
add esi,4
add edi,4
add ebx,4
popfd
loop L1
sbb word ptr [ebx],0
popad
ret
Extended_Sub ENDP
END main
********************************************************* Q8 ****************************************************************
INCLUDE Irvine32.inc


.data
op1 QWORD 0A2B2A40674981234h
op2 QWORD 08010870000234502h
result QWORD 1 DUP(0) ; = 22C32B0674BB5736
msg BYTE "The addition equals ",0
DoubleWords = SIZEOF op1 / TYPE DWORD


.code
main PROC
mov esi, OFFSET op1
mov edi, OFFSET op2
mov ebx, OFFSET result
mov ecx, DoubleWords
call Extended_Add
mov edx, OFFSET msg
call WriteString
mov esi, OFFSET result
add esi, DoubleWords * 4
mov ecx, DoubleWords
L1: sub esi, TYPE DWORD
mov eax, [esi]
call WriteHex
loop L1
call Crlf
exit
main ENDP

Extended_Add PROC
pushad
clc
L1: mov eax,[esi]
adc eax,[edi]
pushfd
mov [ebx],eax
add esi,4
add edi,4
add ebx,4
popfd
loop L1
sbb word ptr [ebx],0
popad
ret
Extended_Add ENDP
END main
********************************************************* Q9 ****************************************************************
Include Irvine32.inc

.data
arrA dword 5,24,432
arrB dword 20,18,226

.code

gcd PROTO a:dword, b:dword

main PROC
mov esi,0

mov ecx, 3

l4:
invoke gcd, arrA[esi*type arrA],arrB[esi*type arrB]
call writedec
call crlf
inc esi
loop l4


exit
main ENDP

gcd PROC a:dword, b:dword
mov edx,a
mov ebx,b

cmp a,0
je l1

cmp b,0
je l2

cmp a,ebx
je l2

jmp continue

l1:
mov eax,b
ret 8

l2:
mov eax,a
ret 8

continue:
cmp a,ebx
ja condition1

condition2:
sub ebx,a
invoke gcd, a,ebx
jmp quit

condition1:
sub edx,b
invoke gcd, edx,b
jmp quit


quit:
ret 8
gcd ENDP
end main

********************************************************* Q10 ****************************************************************
Include Irvine32.inc
.data

arrA sdword -5,-2,3,-5,17,-17
arrB sdword 5,-2,3,-5,-69,69,420
arrLen dword 2 DUP(?)
difference sdword 5												;Difference should be postive value

.code

CountNearMatches PROTO arr1:ptr sdword, arr2:ptr sdword, Len:ptr dword, diff:sdword

main PROC
mov esi,0
mov arrLen[esi*type arrLen],lengthof arrA
inc esi
mov arrLen[esi*type arrLen],lengthof arrB

invoke CountNearMatches, ADDR arrA, ADDR arrB, ADDR arrLen, difference



exit
main ENDP

CountNearMatches PROC arr1:ptr sdword, arr2:ptr sdword, Len:ptr dword, diff:sdword
LOCAL count:dword
pushad
mov eax, 0
mov count,0
mov esi, Len
mov ebx, [esi]
add esi, 4
cmp ebx,[esi]				;Arr1 > Arr2
jg l1

l1:
sub esi,4
mov ecx,[esi]
jmp continue

l2:
mov ecx,[esi]

continue:
l3:
mov esi,arr1
add esi,count
mov ebx,[esi]
mov esi,arr2
add esi,count
sub ebx,[esi]
cmp ebx,0		
jge idk
neg ebx			;absolute the value

idk:
cmp ebx,diff			;Difference should be postive value
jg next
inc eax

next:
add count,4
loop l3

call writedec
popad
ret
CountNearMatches ENDP
end main